Cover Sheet

Abstract
	In this exercise a digital comparator was constructed using VHDL programming techniques in 
combonination with the Xilinx development program. The comparator was designed in VHDL mostly with given code.
A testbench was designed to verify the correct functionality and then the design was simulated using the testbench
and "real world" scenarios. Finally, the design was synthesized onto an FPGA.The exercise provided insight into 
the different styles of VHDL programming as well as the LUT approach in FPGAs. The exercise was a succes, as the 
comparator worked as designed and behaved correctly when tested and synthesized.

Design Methodology
	This exercise required the use of of the Xilinx ISE development tools and the VHDL programming language. In 
order to begin the exercise a new projectr had ti  be created in the Xilinx IDE. Once the settings were correctly
set for the Spartan 6 board that would later be used, the components of the comparator could be implemented. The
combonation of these components created the digital comparator.
			Figure (1.1): Top-Level Block Diagram of a Two-Bit Digital Comparator
	As seen in Figure (1.1), the design incoperated five design units. These design units were; the If-Then-Else 
Statement, the When-Else statement, the Boolean Equation, the Primative LUT, and the Top-Level Wrapper (Figures
(1.2),(1.3),(1.4),(1.5), and (1.6) respectivly). All wereadded to the project by using the heirarchy window and adding a 
new source. For all of the design unit, the code was given, except the Primative LUT. In order to impliment the 
LUT, first, the INIT value of the LUT had to be determined using a truth table.
			Table(1.1): Primative LUT truth table
	The design of the primative LUT can be seen in Table(1.1). Using the INIT value determined by the table, the
VHDL code was found in the Xilinx library. In order to be correctly implemented, the code had to be modified to 
contain the right signals variables which were used in other design units. Once the LUT was implemented, the 
testbench could be designed.
	The testbench used a for loop to test the 16 possible combonations for the input variables. The code for this
testbench was also provided and can be found in Figure (1.7). In order to confirm no unwanted changes were made 
in the copying and pasting of code,the syntax was checked using the IDE's built in debugger in the synthesis tools
. Once the code was correctly implemented, the simulation could occur.
	By following the steps provided at the begining of the exercise the simulation took place and was verfied to
be correct by the waveform model generated. Even though the correct waveform was generated, for the purposes of this exercise,
the testbench was modified to contian produce an incorrect waveform. These changes and the resulting incorrect
waveform can be seen in Figures (1.8) and (1.9), respectivly. 
	This verfied the design of the comparator was correct and the project was ready to be synthesized.Synthesis is
the process in which the software decides what logic gates are required in the design. By following the steps 
provided for synthesis the program synthesized the design. The resulting design of the if-then-else, when-else,
and Boolean equation can be seen in Figure (2.0), which was captured following the synthesis.
	Following synthesis, a post-route simulation took place. This is also known as a timing simulation because
the process uses true timing delays information in the design. It is used to simulate the the design after it has 
been routed to the FPGA. The resulting waveform, with correct timing delays, can be found in Figure(2.1).
	Finally the comparator could be implemented on the FPGA. This was, once again, done using the Xilinx software.
Once the comparator was programmed onto the board, the board was tested and verfied to be correct by using 
different combonations of the input variables. These results were compared to the expected results from the first
testbench. 

Results

Conclusion
	In this exercise, several VHDL programming techniques and the Xilinx development program were used. The 
exercise served to show as an example of how to VHDL programs can be synthesized into hardware. The objectives of the 
exercise were met. The design, synthesis, simulation, and hardware implemenation all resulted in correct results.
This shows that the exercise was carried out correctly and can b e used as a steppping stone for larger and more
complex exercises in the future. 
	